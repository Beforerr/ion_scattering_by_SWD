[
  {
    "objectID": "notebooks/sim_analysis.html",
    "href": "notebooks/sim_analysis.html",
    "title": "",
    "section": "",
    "text": "using DrWatson\n@quickactivate\nusing Revise\nusing CairoMakie\nincludet(\"../src/main.jl\")\ninclude(\"../src/io.jl\")\n\n┌ Warning: Using an un-quoted Symbol on the LHS is deprecated. Write :tmax = ... instead.\n└ @ DataFramesMeta /Users/zijin/.julia/packages/DataFramesMeta/Ga6VV/src/parsing.jl:387\n\n\nsplit_results (generic function with 1 method)\nFor the same parameter, the left-hand transition matrix \\(M_l\\) has a 180-degree rotation about the right-hand matrix \\(M_r\\) : \\(M_l[i,j] = M_r[n-i,n-j]\\)."
  },
  {
    "objectID": "notebooks/sim_analysis.html#test-the-different-algorithms-for-the-problem",
    "href": "notebooks/sim_analysis.html#test-the-different-algorithms-for-the-problem",
    "title": "",
    "section": "Test the different algorithms for the problem",
    "text": "Test the different algorithms for the problem\n\ndir = \"test_alg\"\ndf = get_result(; dir);\n\n┌ Info: Scanning folder /Users/zijin/projects/ion_scattering_by_SWD/data/test_alg for result files.\n└ @ DrWatson /Users/zijin/.julia/packages/DrWatson/8XYbJ/src/result_collection.jl:117\n┌ Info: Added 54 entries.\n└ @ DrWatson /Users/zijin/.julia/packages/DrWatson/8XYbJ/src/result_collection.jl:193\n\n\n\nfor subdf in groupby(df, :alg)\n    pa_pair_hist(subset_leave(subdf)) |&gt; display\n    pa_pair_hist(subset_trap(subdf)) |&gt; display\nend"
  },
  {
    "objectID": "notebooks/sim_analysis.html#test-the-different-algorithms-for-the-problem-1",
    "href": "notebooks/sim_analysis.html#test-the-different-algorithms-for-the-problem-1",
    "title": "",
    "section": "Test the different algorithms for the problem",
    "text": "Test the different algorithms for the problem\n\npa_pair_plot(ldf, rdf) |&gt; display\npa_pair_plot(ldf, rdf; func) |&gt; display\npa_pair_plot(ldf, rdf; func=func_t) |&gt; display\n\n\n\n\n\n\n\nBoundsError: BoundsError: attempt to access 0-element Vector{Any} at index [1]\nBoundsError: attempt to access 0-element Vector{Any} at index [1]\n\n\n\nStacktrace:\n\n [1] throw_boundserror(A::Vector{Any}, I::Tuple{Int64})\n\n   @ Base ./essentials.jl:14\n\n [2] getindex(A::Vector{Any}, i::Int64)\n\n   @ Base ./essentials.jl:915\n\n [3] pa_pair_plot(ldf::DataFrame, rdf::DataFrame; s::Symbol, func::Function, figure::@NamedTuple{size::Tuple{Int64, Int64}})\n\n   @ Main ~/projects/ion_scattering_by_SWD/src/plot.jl:42\n\n [4] top-level scope\n\n   @ ~/projects/ion_scattering_by_SWD/notebooks/jl_notebook_cell_df34fa98e69747e1a8f8a730347b8e2f_W4sZmlsZQ==.jl:3\n\n\n\npa_pair_plot(ldf, rdf; s = :β, func)\n\n\n\n\n\nfig = Figure(; size=(1200, 1000,))\ngridsl = pa_diff_plot!(fig[1,1], func(ldf))\ngridsr = pa_diff_plot!(fig[3,1], func(rdf))\nsign_label(fig)\nlegend!(fig[:,end+1], gridsl)\nfig\n\n\n\n\n\ntdf = @subset(func(df), :v .== 8, :θ .== 45);\nl = data(tdf) * mapping(col=sign_map,row=β_map)\nw1_map_plot(l; color=Δα)\n\n\n\n\n\n# Create a layer with faceting for α, β, and v\nbegin\n    using GLMakie\n    GLMakie.activate!()\n    fg = pa_pair_plot(layer; figure = figure)\nend"
  },
  {
    "objectID": "notebooks/main.html",
    "href": "notebooks/main.html",
    "title": "",
    "section": "",
    "text": "import hvplot.pandas\nimport hvplot.xarray\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport panel as pn\nimport pyspedas\nimport pytplot\nimport xarray as xr\nfrom loguru import logger\nfrom matplotlib.patches import Circle\nfrom pytplot import get_data, options, tplot, tplot_copy\n\n# import proplot as pplt # not compatible with pytplot\n\n\npn.extension(sizing_mode=\"stretch_width\")\n\nfrom utils import *\nFor theoretical self-consistent model, the magnetic field is given by Bl=B0tanh(z/L) And we define the thickness tanh(1)=0.76 z=L, Bl=0.46B0\nUsing the solar wind velocity projected onto the normal direction to the SWD surface, that of the minimum variance, \\(n\\), we transform time to space \\(r_n\\)\nAveraged ion velocity in mn direction (more reliable than n direction)\n$v_{mn} = | - ( ) | = |v_m + v_n | = $\ndef calculate_RD_parameter(Bl, Bm, Bn=None, num_avg_points=8):\n    \"\"\"Calculate magnetic field parameters for rotation discontinuity (RD) identification.\n\n    Args:\n        Bl (xarray.DataArray): 'Bl' component of the magnetic field.\n        Bm (xarray.DataArray): 'Bm' component of the magnetic field.\n         Bn (xarray.DataArray, optional): 'Bn' component of the magnetic field. Defaults to None.\n        num_avg_points (int): Number of points at the start and end of data for averaging.\n\n    Returns:\n        tuple: A tuple containing 'Bl_max' and 'Bm0', and 'Bn0' if 'Bn' was provided.\n    \"\"\"\n\n    radius = np.sqrt(Bl**2 + Bm**2).mean(dim=\"time\")\n\n    # Calculate 'Bm0'\n    Bm_start = Bm[:num_avg_points].mean(dim=\"time\")\n    Bm_end = Bm[-num_avg_points:].mean(dim=\"time\")\n    Bm0 = (Bm_start + Bm_end) / 2\n\n    # Calculate 'Bl_max': average of the absolute values of 'Bl' at the start and end of the data\n    # Bl_start = Bl[:num_avg_points].mean(dim=\"time\")\n    # Bl_end = Bl[-num_avg_points:].mean(dim=\"time\")\n    # Bl_max = (np.abs(Bl_start) + np.abs(Bl_end)) / 2\n\n    # Calculate 'Bl_max': using radius, more reliable\n    Bl_max = np.sqrt(radius**2 - Bm0**2)\n\n    # Calculate 'Bn0' if 'Bn' is provided, else return 'Bl_max' and 'Bm0' only\n    if Bn is not None:\n        Bn0 = Bn.mean(dim=\"time\")\n        return Bl_max.values, Bm0.values, Bn0.values\n\n    return Bl_max.values, Bm0.values\ndef hodographs(B1, B2):\n    \"\"\"Hodograms of the magnetic field components.\n\n    Args:\n        B1 (xr.DataArray): Magnetic field component 1.\n        B2 (xr.DataArray): Magnetic field component 2.\n    \"\"\"\n\n    radius = np.sqrt(B1**2 + B2**2).mean(dim=\"time\")\n\n    fig, ax = plt.subplots()\n    (line,) = ax.plot(B1, B2, label=\"Observation\")\n\n    # Add a circle\n    circle = Circle(\n        (0, 0),\n        radius,\n        edgecolor=\"red\",\n        linestyle=\"--\",\n        facecolor=\"none\",\n        label=r\"$B_m^2+B_l^2=B_{l,max}^2+B_{m,0}^2$\",\n    )\n\n    circle = ax.add_artist(circle)\n\n    ax.set_xlabel(f\"{B1.attrs['long_name']} [{B1.attrs['units']}]\")\n    ax.set_ylabel(f\"{B2.attrs['long_name']} [{B2.attrs['units']}]\")\n    ax.legend(handles=[line, circle], frameon=False)\n\n    return fig, ax\n\n\ndef hodographs_BlBm(Bl, Bm):\n    \"\"\"Hodograms of the magnetic field components.\n\n    Args:\n        Bl (xr.DataArray): Magnetic field component 1.\n        Bm (xr.DataArray): Magnetic field component 2.\n    \"\"\"\n\n    fig, ax = hodographs(Bl, Bm)\n\n    Bl_max, Bm0 = calculate_RD_parameter(Bl, Bm)\n\n    plt.axvline(x=Bl_max, color=\"g\", linestyle=\":\", label=r\"$B_{l,max}$\")\n    plt.axvline(x=-Bl_max, color=\"g\", linestyle=\":\", label=r\"$-B_{l,max}$\")\n    plt.axhline(y=Bm0, color=\"g\", linestyle=\":\", label=r\"$B_{m,0}$\")\n    plt.text(Bl_max, Bm0, r\"$B_{m,0}$\", color=\"g\")\n    plt.text(-Bl_max, Bm0, r\"$B_{l,max}$\", color=\"g\")\n    plt.text(-Bl_max, Bm0, r\"$-B_{l,max}$\", color=\"g\")\n\n    return fig, ax\ndef get_thx_density(probe, trange, datatype=\"peem\"):\n    \"\"\"get plasma density\n    Note: better to get from electron mom data, peem_density, ion density is not as accurate\n    \"\"\"\n    tstart, tstop = trange[0], trange[1]\n\n    # Get plasma density\n    tname = f\"th{probe}_{datatype}_density\"\n    if not data_exists_tr(tname, *trange):\n        pyspedas.themis.mom(probe=probe, trange=trange, varnames=[tname])\n\n    thx_density = (\n        get_data(tname, xarray=True).sortby(\"time\").sel(time=slice(tstart, tstop))\n    )  # Need to sort by time before slicing, otherwise error: KeyError: 'Value based partial slicing on non-monotonic DatetimeIndexes with non-existing keys is not allowed.'\n    thx_density_averaged = thx_density.mean(dim=\"time\")\n    return thx_density_averaged.values\n\n\ndef get_thx_max_flux_energy(probe, trange, datatype=\"peir\"):\n    tstart, tstop = trange[0], trange[1]\n\n    tname = f\"th{probe}_{datatype}_en_eflux\"\n\n    if not data_exists_tr(tname, *trange):\n        pyspedas.themis.esa(probe=probe, trange=trange, varnames=[tname])\n\n    thx_eflux = get_data(tname, xarray=True).sel(\n        time=slice(tstart, tstop)\n    )  # time_clip does not work for this variable (does not copy `spec_bins`)\n    e_index = thx_eflux.sum(dim=\"time\").argmax(dim=\"v_dim\")\n    thx_energy_max = thx_eflux.spec_bins.sel(v_dim=e_index).mean(dim=\"time\")\n    return thx_energy_max.values\n\n\n# DEBUG\n# get_data('thc_peem_density', xarray=True).hvplot()\ndef prcess_mva(event, plot=False, save=False, detail=True):\n    # Define variables\n    tstart, tstop, probe = event[\"tstart\"], event[\"tstop\"], event[\"probe\"]\n    trange = [tstart, tstop]\n    datatype = event.get(\"datatype\", \"fgs\")\n\n    tplot_vars = [\"thx_fgm\", \"thx_fgm_all\"]\n\n    # Convert magnetic field from GSM to MVA coordinates\n    mva_data = thx_mag_prod(probe, tstart, tstop, datatype, coord=\"mva\")\n\n    Bl = mva_data.sel(v_dim=0)\n    Bm = mva_data.sel(v_dim=1)\n    Bn = mva_data.sel(v_dim=2)\n    Bl.attrs[\"long_name\"] = \"$B_l$\"\n    Bl.attrs[\"units\"] = \"nT\"\n    Bm.attrs[\"long_name\"] = \"$B_m$\"\n    Bm.attrs[\"units\"] = \"nT\"\n\n    Bl_max, Bm0, Bn0 = calculate_RD_parameter(Bl, Bm, Bn)\n\n    # Initialize dictionary for results\n    result_dict = {}\n    result_dict[\"Bl_max\"] = Bl_max\n    result_dict[\"Bm0\"] = Bm0\n    result_dict[\"Bn0\"] = Bn0\n\n    # Calculate detail if detail flag is set to True\n    if detail:\n        # Define variables related to ion velocity and flux\n        thx_ion_vel_tname = f\"th{probe}_peir_velocity_gsm\"\n\n        if not data_exists_tr(thx_ion_vel_tname, *trange):\n            pyspedas.themis.esa(\n                probe=probe, trange=trange, varnames=[thx_ion_vel_tname]\n            )\n\n        # Convert ion velocity from GSM to MVA coordinates\n        tplot_copy(thx_ion_vel_tname, \"thx_ion_vel\")\n        time_clip(\"thx_ion_vel\", tstart, tstop, suffix=\"\")\n        tvector_rotate(\"thx_fgm_mva_mat\", \"thx_ion_vel\")\n        tplot_vars += [\"thx_ion_vel\", \"thx_ion_vel_rot\"]\n        # Get averaged ion velocity in the normal direction\n        # thx_ion_vel_n = get_data(\"thx_ion_vel_rot\", xarray=True).sel(v_dim=2).mean(dim=\"time\").values\n        # print_string += f\" 'thx_ion_vel_n': {thx_ion_vel_n:.2f},\"\n\n        # Get averaged ion velocity in mn direction (more reliable than n direction)\n        thx_ion_vel_mn_ts = get_data(\"thx_ion_vel_rot\", xarray=True).sel(v_dim=[1, 2])\n        thx_ion_vel_mn = (\n            np.sqrt(np.square(thx_ion_vel_mn_ts).sum(dim=\"v_dim\"))\n            .mean(dim=\"time\")\n            .values\n        )\n        result_dict[\"thx_ion_vel_mn\"] = thx_ion_vel_mn\n\n        # Calculate thickness\n        c1 = 0.76\n        time = mva_data.time.to_numpy().astype(\"datetime64[ns]\")\n        t_pos = time[np.abs(Bl + c1 * Bl_max).argmin(dim=\"time\")]\n        t_neg = time[np.abs(Bl - c1 * Bl_max).argmin(dim=\"time\")]\n        L = (\n            thx_ion_vel_mn * ((t_pos - t_neg).astype(\"float64\"))\n        ) * 1e-9  # L = (thx_ion_vel_n * ((t_pos - t_neg).astype(\"float64\"))) * 1e-9\n        result_dict[\"L\"] = L\n\n        # Get max ion energy flux and plasma density\n        result_dict[\"thx_ion_energy_max\"] = get_thx_max_flux_energy(probe, trange)\n        result_dict[\"n_p\"] = get_thx_density(probe, trange)\n\n    # Plotting the data\n    if plot:\n        # Calculate distance\n        t_origin = time[np.abs(Bl).argmin(dim=\"time\")]\n        distance = (\n            thx_ion_vel_mn * ((time - t_origin).astype(\"float64\"))\n        ) * 1e-9  # distance = (thx_ion_vel_n * ((time - t_origin).astype(\"float64\"))) * 1e-9\n        pytplot.store_data(\"distance\", data={\"x\": time, \"y\": distance})\n        options(\"distance\", \"ysubtitle\", \"[km]\")\n\n        filename = f\"../figures/{tstart}\" if save else \"\"\n        var_label = \"distance\" if detail else \"\"\n        tplot(tplot_vars, var_label=var_label, save_svg=filename)\n\n        fig, ax = hodographs_BlBm(Bl, Bm)\n        fig.savefig(f\"../figures/{tstart}_mva.svg\") if save else None\n\n    # logger.info(print_string)\n    # Convert numpy array values to native Python types\n    for key in result_dict:\n        if isinstance(result_dict[key], np.ndarray) and result_dict[key].size == 1:\n            result_dict[key] = result_dict[key].item()\n\n    return result_dict\nraw_events = [\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 11:33:37\",\n        \"tstop\": \"2019-01-06 11:33:53\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.23,\n        \"Bm0\": 1.77,\n        \"Bn0\": 1.20,\n        \"thx_ion_vel_n\": -337.90,\n        \"L\": 4688.31,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 4.89,\n        \"quality\": \"soso, waving\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 11:47:00\",\n        \"tstop\": \"2019-01-06 11:47:15\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.78,\n        \"Bm0\": 3.63,\n        \"Bn0\": 2.29,\n        \"thx_ion_vel_n\": -283.08,\n        \"L\": 1857.74,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 4.50,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 15:54:05\",\n        \"tstop\": \"2019-01-06 15:54:39\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.77,\n        \"Bm0\": 1.97,\n        \"Bn0\": 6.38,\n        \"thx_ion_vel_n\": -85.12,\n        \"L\": -2000.34,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 0.64,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 16:08:55\",\n        \"tstop\": \"2019-01-06 16:09:13\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.08,\n        \"Bm0\": 6.26,\n        \"Bn0\": 2.18,\n        \"thx_ion_vel_n\": -187.13,\n        \"L\": -2070.15,\n        \"thx_ion_energy_max\": 1771.15,\n        \"n_p\": 0.55,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 16:37:01\",\n        \"tstop\": \"2019-01-06 16:38:10\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.30,\n        \"Bm0\": -4.44,\n        \"Bn0\": 4.79,\n        \"thx_ion_vel_n\": -444.92,\n        \"L\": 16045.03,\n        \"thx_ion_energy_max\": 2332.04,\n        \"n_p\": 0.48,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 16:39:06\",\n        \"tstop\": \"2019-01-06 16:39:45\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.00,\n        \"Bm0\": 3.83,\n        \"Bn0\": 5.55,\n        \"thx_ion_vel_n\": -353.01,\n        \"L\": -7567.59,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 0.86,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T17:40:50\",\n        \"tstop\": \"2019-01-06T17:41:50\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.71,\n        \"Bm0\": 1.35,\n        \"Bn0\": -0.63,\n        \"thx_ion_vel_n\": -343.57,\n        \"L\": -13871.65,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 5.85,\n        \"quality\": \"soso, waving, large interval\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T17:46:40\",\n        \"tstop\": \"2019-01-06T17:46:55\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.82,\n        \"Bm0\": 1.68,\n        \"Bn0\": 1.34,\n        \"thx_ion_vel_n\": -503.10,\n        \"L\": 1792.29,\n        \"thx_ion_energy_max\": 1771.15,\n        \"n_p\": 4.01,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T17:48:00\",\n        \"tstop\": \"2019-01-06T17:48:40\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.59,\n        \"Bm0\": 2.99,\n        \"Bn0\": 0.87,\n        \"thx_ion_vel_n\": -513.37,\n        \"L\": 6288.79,\n        \"thx_ion_energy_max\": 1771.15,\n        \"n_p\": 3.75,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T19:26:14\",\n        \"tstop\": \"2019-01-06T19:26:35\",\n        \"datatype\": \"fgs\",\n        \"Bl_max\": 2.16,\n        \"Bm0\": -3.05,\n        \"Bn0\": 3.20,\n        \"thx_ion_vel_n\": -170.46,\n        \"L\": 1398.71,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 5.33,\n        \"quality\": \"soso, low resolution\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T19:55:21\",\n        \"tstop\": \"2019-01-06T19:55:29\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.53,\n        \"Bm0\": -1.77,\n        \"Bn0\": -0.07,\n        \"thx_ion_vel_n\": 410.07,\n        \"L\": -1460.86,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 4.90,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T19:59:45\",\n        \"tstop\": \"2019-01-06T19:59:50\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.70,\n        \"Bm0\": 0.86,\n        \"Bn0\": -3.94,\n        \"thx_ion_vel_n\": 340.09,\n        \"L\": -233.81,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 3.96,\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T20:08:15\",\n        \"tstop\": \"2019-01-06T20:08:25\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.81,\n        \"Bm0\": 3.71,\n        \"Bn0\": 0.07,\n        \"thx_ion_vel_n\": -332.01,\n        \"L\": -1473.31,\n        \"thx_ion_energy_max\": 1345.45,\n        \"n_p\": 4.43,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06T20:14:27.40\",\n        \"tstop\": \"2019-01-06T20:14:33\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.08,\n        \"Bm0\": -1.41,\n        \"Bn0\": -1.12,\n        \"L\": -1053.43,\n        \"thx_ion_vel_n\": 432.18,\n        \"thx_ion_energy_max\": 1771.15,\n        \"n_p\": 4.71,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T06:02:30\",\n        \"tstop\": \"2019-01-07T06:05:00\",\n        \"datatype\": \"fgs\",\n        \"Bl_max\": 1.44,\n        \"Bm0\": 2.10,\n        \"Bn0\": 1.27,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T06:27:00\",\n        \"tstop\": \"2019-01-07T06:27:40\",\n        \"datatype\": \"fgs\",\n        \"Bl_max\": 2.05,\n        \"Bm0\": -2.49,\n        \"Bn0\": -0.35,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:13:11\",\n        \"tstop\": \"2019-01-07T09:13:40\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.75,\n        \"Bm0\": -2.28,\n        \"Bn0\": -1.68,\n        \"L\": -6610.43,\n        \"thx_ion_vel_n\": 431.70,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:20:08\",\n        \"tstop\": \"2019-01-07T09:20:22\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.41,\n        \"Bm0\": 2.59,\n        \"Bn0\": -0.02,\n        \"L\": 1606.09,\n        \"thx_ion_vel_n\": -133.15,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:24:15\",\n        \"tstop\": \"2019-01-07T09:24:45\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.72,\n        \"Bm0\": -1.56,\n        \"Bn0\": 2.45,\n        \"L\": 1495.13,\n        \"thx_ion_vel_n\": -72.27,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:31:57.30\",\n        \"tstop\": \"2019-01-07T09:32:05\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.86,\n        \"Bm0\": -2.62,\n        \"Bn0\": -0.67,\n        \"L\": -885.86,\n        \"thx_ion_vel_n\": 308.12,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:34:28\",\n        \"tstop\": \"2019-01-07T09:34:31\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.18,\n        \"Bm0\": 1.21,\n        \"Bn0\": 2.99,\n        \"L\": 449.99,\n        \"thx_ion_vel_n\": -378.94,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso, large Bn\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:38:31\",\n        \"tstop\": \"2019-01-07T09:38:45\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.33,\n        \"Bm0\": -1.26,\n        \"Bn0\": -2.48,\n        \"L\": 3494.37,\n        \"thx_ion_vel_n\": 411.10,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso, large Bn\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:40:31\",\n        \"tstop\": \"2019-01-07T09:41:02\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.03,\n        \"Bm0\": -2.22,\n        \"Bn0\": -0.44,\n        \"L\": 9551.26,\n        \"thx_ion_vel_n\": -428.07,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso, sensitive to time interval\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:41:17\",\n        \"tstop\": \"2019-01-07T09:41:35\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.74,\n        \"Bm0\": -1.42,\n        \"Bn0\": 0.25,\n        \"L\": -1994.58,\n        \"thx_ion_vel_n\": -301.07,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:44:45\",\n        \"tstop\": \"2019-01-07T09:44:57\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.16,\n        \"Bm0\": 2.32,\n        \"Bn0\": 0.15,\n        \"L\": -1300.35,\n        \"thx_ion_vel_n\": -288.97,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T09:45:02\",\n        \"tstop\": \"2019-01-07T09:45:11\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.65,\n        \"Bm0\": 1.44,\n        \"Bn0\": -0.12,\n        \"L\": 1686.95,\n        \"thx_ion_vel_n\": -391.18,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:05:06.30\",\n        \"tstop\": \"2019-01-07T10:05:12\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.77,\n        \"Bm0\": -2.84,\n        \"Bn0\": 0.75,\n        \"L\": -1349.08,\n        \"thx_ion_vel_n\": 423.24,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:08:29\",\n        \"tstop\": \"2019-01-07T10:08:47\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.07,\n        \"Bm0\": 2.70,\n        \"Bn0\": -0.14,\n        \"L\": 6583.74,\n        \"thx_ion_vel_n\": -450.17,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:33:22\",\n        \"tstop\": \"2019-01-07T10:33:26\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.45,\n        \"Bm0\": 2.41,\n        \"Bn0\": 2.74,\n        \"L\": 511.43,\n        \"thx_ion_vel_n\": -263.97,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"soso, large Bn\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:50:10\",\n        \"tstop\": \"2019-01-07T10:50:24\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.88,\n        \"Bm0\": 1.29,\n        \"Bn0\": 0.72,\n        \"L\": -1637.17,\n        \"thx_ion_vel_n\": -327.43,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:52:12\",\n        \"tstop\": \"2019-01-07T10:52:18\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.65,\n        \"Bm0\": 1.96,\n        \"Bn0\": -0.33,\n        \"L\": 445.06,\n        \"thx_ion_vel_n\": -245.55,\n        \"thx_ion_energy_max\": 1345.45,\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:53:21\",\n        \"tstop\": \"2019-01-07T10:56:12\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T10:57:47\",\n        \"tstop\": \"2019-01-07T11:03:59\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:01:47\",\n        \"tstop\": \"2019-01-07T11:09:09\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:11:24\",\n        \"tstop\": \"2019-01-07T11:14:25\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:11:24\",\n        \"tstop\": \"2019-01-07T11:14:25\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:22:48\",\n        \"tstop\": \"2019-01-07T11:24:32\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:29:38\",\n        \"tstop\": \"2019-01-07T11:34:32\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:37:33\",\n        \"tstop\": \"2019-01-07T11:42:21\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:41:01\",\n        \"tstop\": \"2019-01-07T11:45:43\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T11:59:26\",\n        \"tstop\": \"2019-01-07T12:03:36\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:14:31\",\n        \"tstop\": \"2019-01-07T12:17:54\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:18:21\",\n        \"tstop\": \"2019-01-07T12:19:12\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:21:10\",\n        \"tstop\": \"2019-01-07T12:23:13\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:27:25\",\n        \"tstop\": \"2019-01-07T12:31:27\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:31:11\",\n        \"tstop\": \"2019-01-07T12:33:13\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:38:07\",\n        \"tstop\": \"2019-01-07T12:41:37\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:42:25\",\n        \"tstop\": \"2019-01-07T12:44:35\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:45:41\",\n        \"tstop\": \"2019-01-07T12:49:11\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:51:18\",\n        \"tstop\": \"2019-01-07T12:53:52\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T12:57:47\",\n        \"tstop\": \"2019-01-07T13:01:04\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:02:31\",\n        \"tstop\": \"2019-01-07T13:04:59\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:05:27\",\n        \"tstop\": \"2019-01-07T13:06:13\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:06:04\",\n        \"tstop\": \"2019-01-07T13:08:42\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:20:13\",\n        \"tstop\": \"2019-01-07T13:23:52\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:25:55\",\n        \"tstop\": \"2019-01-07T13:32:47\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:48:13\",\n        \"tstop\": \"2019-01-07T13:51:50\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T13:58:05\",\n        \"tstop\": \"2019-01-07T14:00:31\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:00:33\",\n        \"tstop\": \"2019-01-07T14:01:35\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:09:36\",\n        \"tstop\": \"2019-01-07T14:12:33\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:15:36\",\n        \"tstop\": \"2019-01-07T14:17:18\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:22:06\",\n        \"tstop\": \"2019-01-07T14:23:46\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:25:06\",\n        \"tstop\": \"2019-01-07T14:27:52\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:34:40\",\n        \"tstop\": \"2019-01-07T14:38:08\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T14:37:53\",\n        \"tstop\": \"2019-01-07T14:45:51\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T15:08:59\",\n        \"tstop\": \"2019-01-07T15:25:45\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T16:16:22\",\n        \"tstop\": \"2019-01-07T17:02:42\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T17:51:52\",\n        \"tstop\": \"2019-01-07T18:15:32\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-07T18:09:19\",\n        \"tstop\": \"2019-01-07T18:24:20\",\n        \"datatype\": \"fgl\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2020-02-19 00:25:40\",\n        \"tstop\": \"2020-02-19 00:25:55\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 4.768192738110849,\n        \"Bm0\": 7.686530972594898,\n        \"Bn0\": 1.9736601167997532,\n        \"quality\": \"waving\",\n        \"thx_ion_vel_mn\": 318.1195455936361,\n        \"thx_ion_energy_max\": 589.7517700195312,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2020-02-19 04:39:00\",\n        \"tstop\": \"2020-02-19 04:39:40\",\n        \"datatype\": \"fgs\",\n        \"Bl_max\": 4.449951459371009,\n        \"Bm0\": 6.549976122277972,\n        \"Bn0\": -0.7438622943608969,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2020-02-19 06:27:32\",\n        \"tstop\": \"2020-02-19 06:27:38\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n        \"Bl_max\": 4.646400176724599,\n        \"Bm0\": -3.857887514402382,\n        \"Bn0\": 1.5164913620549683,\n        \"L\": 544.5,\n        \"energy_max\": 1022.2870483398438,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2020-02-19 08:19:09\",\n        \"tstop\": \"2020-02-19 08:19:13\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 3.999922551838544,\n        \"Bm0\": -4.129371790979183,\n        \"Bn0\": 0.39520660997553475,\n        \"quality\": \"good\",\n        \"thx_ion_vel_mn\": 284.2360012191073,\n        \"thx_ion_energy_max\": 1345.8341064453125,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2020-02-20 02:35:37\",\n        \"tstop\": \"2020-02-20 02:35:53\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.6859416341815625,\n        \"Bm0\": -1.9787655396978097,\n        \"Bn0\": 0.5099011624613212,\n        \"quality\": \"good\",\n        \"thx_ion_vel_mn\": 383.2802191661173,\n        \"thx_ion_energy_max\": 776.968505859375,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-01-12 03:07:32\",\n        \"tstop\": \"2021-01-12 03:07:35\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n        \"Bl_max\": 2.891977682401448,\n        \"Bm0\": -4.843614311016452,\n        \"Bn0\": -1.947426599144735,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-01-12 06:28:15\",\n        \"tstop\": \"2021-01-12 06:28:20\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n        \"Bl_max\": 2.508285900921373,\n        \"Bm0\": 4.508437164205484,\n        \"Bn0\": -0.605711593677448,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-01-13 07:45:17\",\n        \"tstop\": \"2021-01-13 07:45:30\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"bad\",\n        \"Bl_max\": 2.609658135051226,\n        \"Bm0\": 4.624308552001889,\n        \"Bn0\": -1.1605201660183038,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-01-14 04:01:50\",\n        \"tstop\": \"2021-01-14 04:03:00\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n        \"Bl_max\": 3.4453850747655315,\n        \"Bm0\": 2.561887235949561,\n        \"Bn0\": -0.22949910219023723,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-03-12 15:37:07\",\n        \"tstop\": \"2021-03-12 15:37:30\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 1.7684883124009274,\n        \"Bm0\": -3.7139271039491604,\n        \"Bn0\": -0.863374872170262,\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-04-03 04:57:40\",\n        \"tstop\": \"2021-04-03 04:57:55\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n        \"Bl_max\": 2.5026316689074886,\n        \"Bm0\": -1.9860704570152035,\n        \"Bn0\": -0.06739101833563413,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-04-16 19:19:05\",\n        \"tstop\": \"2021-04-16 19:19:15\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n        \"Bl_max\": 8.973848917338131,\n        \"Bm0\": 3.7841571009302024,\n        \"Bn0\": 0.3380442557008978,\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2021-04-18 20:41:33\",\n        \"tstop\": \"2021-04-18 20:41:35.30\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.3629257220712265,\n        \"Bm0\": 4.895827328159069,\n        \"Bn0\": -0.7405799781966877,\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2022-04-04 18:58:16\",\n        \"tstop\": \"2022-04-04 18:58:22\",\n        \"datatype\": \"fgl\",\n        \"Bl_max\": 2.459880337188561,\n        \"Bm0\": -2.931467267219719,\n        \"Bn0\": -0.9352026864241058,\n        \"quality\": \"good\",\n    },\n]\n\nprcess_mva(raw_events[0], plot=True)\n\n22-Jul-23 14:01:25: /Users/zijin/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pytplot/MPLPlotter/tplot.py:623: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  out_ticks.append('{:.2f}'.format(var_xr.interp(coords={'time': time}, kwargs={'fill_value': 'extrapolate', 'bounds_error': False}).values))\n\n22-Jul-23 14:01:25: /Users/zijin/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pytplot/MPLPlotter/tplot.py:623: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  out_ticks.append('{:.2f}'.format(var_xr.interp(coords={'time': time}, kwargs={'fill_value': 'extrapolate', 'bounds_error': False}).values))\n\n22-Jul-23 14:01:25: /Users/zijin/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pytplot/MPLPlotter/tplot.py:623: UserWarning: Converting non-nanosecond precision datetime values to nanosecond precision. This behavior can eventually be relaxed in xarray, as it is an artifact from pandas which is now beginning to support non-nanosecond precision values. This warning is caused by passing non-nanosecond np.datetime64 or np.timedelta64 values to the DataArray or Variable constructor; it can be silenced by converting the values to nanosecond precision ahead of time.\n  out_ticks.append('{:.2f}'.format(var_xr.interp(coords={'time': time}, kwargs={'fill_value': 'extrapolate', 'bounds_error': False}).values))\n\n\n\n\n\n\n\n\n\n\n{'Bl_max': 3.230087591755617,\n 'Bm0': 1.7689997499457184,\n 'Bn0': 1.2022550948066542,\n 'thx_ion_vel_mn': 493.18811615393975,\n 'L': -6842.985111635914,\n 'thx_ion_energy_max': 1345.454345703125,\n 'n_p': 4.890736689998141}\ndef test():\n    event = events[0]\n    tstart, tstop, probe = event[\"tstart\"], event[\"tstop\"], event[\"probe\"]\n    trange = [tstart, tstop]\n    logger.info(f\"trange: {trange}\")\n\n    # Get plasma density\n    thx_density_tname = f\"th{probe}_peem_density\"\n    \"thc_peem_density\"\n    mom_vars = pyspedas.themis.mom(\n        probe=probe, trange=trange, varnames=[thx_density_tname]\n    )\n    thx_density = get_data(thx_density_tname, xarray=True).sel(\n        time=slice(tstart, tstop)\n    )\n    thx_density_averaged = thx_density.mean(dim=\"time\")\n    logger.info(f\"thx_density_averaged: {thx_density_averaged}\")\n    return thx_density.hvplot()\n    # tplot(['thd_peim_velocity_gsm', 'thd_peim_density'])\n    # thd_peim_density = pytplot.get_data('thd_peim_density')\n\n\n# test()"
  },
  {
    "objectID": "notebooks/main.html#example-event",
    "href": "notebooks/main.html#example-event",
    "title": "",
    "section": "Example Event",
    "text": "Example Event\n\nevent = {\n    \"probe\": \"c\",\n    \"tstart\": \"2021-04-03T04:57:40\",\n    \"tstop\": \"2021-04-03T04:57:55\",\n    \"datatype\": \"fgl\",\n    \"quality\": \"good\",\n    'Bl_max': 2.5026316689074886, 'Bm0': -1.9860704570152035, 'Bn0': -0.06739101833563413\n}\n\nrecord = 1\nplot = True\n\nif record:\n    events.append(event)\n    \nif plot:\n    # plot_mva(event, backend=\"matplotlib\",detail=True, save=True)\n    # plot_mva(event, save=True)"
  },
  {
    "objectID": "notebooks/main.html#statistical-analysis",
    "href": "notebooks/main.html#statistical-analysis",
    "title": "",
    "section": "Statistical analysis",
    "text": "Statistical analysis\n\nevents = [\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 11:27:29.30\",\n        \"tstop\": \"2019-01-06 11:27:45\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso, small waving\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 10:41:27\",\n        \"tstop\": \"2019-01-06 10:41:31\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n        \"note\": \"background Bl0?\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 10:39:29\",\n        \"tstop\": \"2019-01-06 10:39:38\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-06 10:39:08\",\n        \"tstop\": \"2019-01-06 10:39:15\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n        \"note\": \"background Bl0?\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 09:21:26\",\n        \"tstop\": \"2019-01-05 09:21:32\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"bad\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 09:14:50\",\n        \"tstop\": \"2019-01-05 09:14:55\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 09:09:12\",\n        \"tstop\": \"2019-01-05 09:09:25\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso, waving\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 09:05:41\",\n        \"tstop\": \"2019-01-05 09:05:47\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso, large Bn0\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 07:43:25\",\n        \"tstop\": \"2019-01-05 07:43:35\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"bad, magnitude dipping\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-05 07:11:29\",\n        \"tstop\": \"2019-01-05 07:11:35\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good, waving\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-01 05:22:51\",\n        \"tstop\": \"2019-01-01 05:22:55\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n        \"note\": \"background Bl0?\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-01 03:49:04.30\",\n        \"tstop\": \"2019-01-01 03:49:11\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"soso\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-01 03:47:57\",\n        \"tstop\": \"2019-01-01 03:48:01\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"bad\",\n        \"note\": \"background Bl0?\",\n    },\n    {\n        \"probe\": \"c\",\n        \"tstart\": \"2019-01-01 00:34:16\",\n        \"tstop\": \"2019-01-01 00:34:26\",\n        \"datatype\": \"fgl\",\n        \"quality\": \"good\",\n    },\n]\n\nfor event in events:\n    try:\n        result_dict = prcess_mva(event, plot=False, save=False)\n        event.update(result_dict)\n    except Exception as e:\n        print(f\"Error processing event {event}: {e}\")\n\n\ndf = pd.DataFrame(events)\n\n\nfrom astropy import units as u\nfrom plasmapy.formulary.lengths import inertial_length\n\ndf[\"k_m\"] = np.abs(df[\"Bm0\"] / df[\"Bl_max\"])\ndf[\"k_n\"] = np.abs(df[\"Bn0\"] / df[\"Bl_max\"])\ndf[\"d_i\"] = (\n    inertial_length(df[\"n_p\"].to_numpy() * u.cm**-3, particle=\"proton\").to(u.km).value\n)\ndf[\"L/d_i\"] = df[\"L\"] / df[\"d_i\"]\ndf.describe()\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pandas/core/indexes/base.py:3653, in Index.get_loc(self, key)\n   3652 try:\n-&gt; 3653     return self._engine.get_loc(casted_key)\n   3654 except KeyError as err:\n\nFile ~/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pandas/_libs/index.pyx:147, in pandas._libs.index.IndexEngine.get_loc()\n\nFile ~/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pandas/_libs/index.pyx:176, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7080, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'n_p'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\n/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb Cell 17 in &lt;cell line: 8&gt;()\n      &lt;a href='vscode-notebook-cell:/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb#X22sZmlsZQ%3D%3D?line=5'&gt;6&lt;/a&gt; df[\"k_m\"] = np.abs(df[\"Bm0\"] / df[\"Bl_max\"])\n      &lt;a href='vscode-notebook-cell:/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb#X22sZmlsZQ%3D%3D?line=6'&gt;7&lt;/a&gt; df[\"k_n\"] = np.abs(df[\"Bn0\"] / df[\"Bl_max\"])\n----&gt; &lt;a href='vscode-notebook-cell:/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb#X22sZmlsZQ%3D%3D?line=7'&gt;8&lt;/a&gt; df[\"d_i\"] = inertial_length(df[\"n_p\"].to_numpy() * u.cm ** -3, particle='proton').to(u.km).value\n      &lt;a href='vscode-notebook-cell:/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb#X22sZmlsZQ%3D%3D?line=8'&gt;9&lt;/a&gt; df[\"L/d_i\"] = df[\"L\"] / df[\"d_i\"]\n     &lt;a href='vscode-notebook-cell:/Users/zijin/projects/solar_wind_discontinuities/notebooks/main.ipynb#X22sZmlsZQ%3D%3D?line=9'&gt;10&lt;/a&gt; df.describe()\n\nFile ~/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pandas/core/frame.py:3761, in DataFrame.__getitem__(self, key)\n   3759 if self.columns.nlevels &gt; 1:\n   3760     return self._getitem_multilevel(key)\n-&gt; 3761 indexer = self.columns.get_loc(key)\n   3762 if is_integer(indexer):\n   3763     indexer = [indexer]\n\nFile ~/mambaforge/envs/cool_solar_wind/lib/python3.10/site-packages/pandas/core/indexes/base.py:3655, in Index.get_loc(self, key)\n   3653     return self._engine.get_loc(casted_key)\n   3654 except KeyError as err:\n-&gt; 3655     raise KeyError(key) from err\n   3656 except TypeError:\n   3657     # If we have a listlike key, _check_indexing_error will raise\n   3658     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3659     #  the TypeError.\n   3660     self._check_indexing_error(key)\n\nKeyError: 'n_p'\n\n\n\n\n# histogram of k_m, with values larger than 1 belonging to the same group\ndf[\"k_m\"].plot(kind=\"hist\")\n# df[\"k_n\"].plot(kind=\"hist\")\n\n\n\n\n\n\n\n\n\n# histogram of k_m, with values larger than 1 belonging to the same group\n# np.abs(df[\"k_m\"]).plot(kind=\"hist\")\n\nfig, axs = plt.subplots()\n\nbin_space = 0.25\n\nbins = np.arange(0, 1 + 2 * bin_space, bin_space)\nticks = np.arange(0, 1 + bin_space, bin_space).tolist()\nticks.append(\"1+\")\n\n# Modify k_m so all values larger than 1 are set to 2\nk_m_grouped = [x if x &lt;= 1 else 1 + bin_space / 2 for x in np.abs(df[\"k_m\"])]\n\n# Then, define bins from 0 to 1 in steps of 0.25, and an additional bin for all values &gt;1\naxs.hist(k_m_grouped, bins=bins)\n\naxs.set_xlabel(r\"$\\kappa_m$\")\naxs.set_ylabel(\"Count\")\n\n# axs.format(\n#     xlabel=r\"$\\kappa_m$\",\n#     ylabel=\"Count\",\n# )\n\n# Adjust x-axis labels to reflect the actual bins in the data\nplt.xticks(bins, ticks)\n\n# fig.savefig(\"../figures/k_m_hist.svg\")\n\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Energetic ion scattering by solar wind discontinuities",
    "section": "",
    "text": "The transport of energetic particles within the heliosphere is significantly influenced by the turbulent magnetic field present in the solar wind. However, this turbulence should not be regarded merely as a collection of random magnetic field fluctuations. Instead, the nonlinear energy cascade process results in the formation of coherent structures. These coherent structures have been shown to act as efficient particle scatterers in non-collisional plasmas (Artemyev et al. 2020).\nWe investigated the interaction of ions with rotational discontinuities by employing a simplified analytical model for the magnetic field configuration. Our study aimed to examine how the particle pitch angle is influenced by the parameters of the magnetic field configuration and the initial conditions of the particles."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Energetic ion scattering by solar wind discontinuities",
    "section": "References",
    "text": "References\n\nF. Malara et al. (2023)\nFrancesco Malara, Perri, and Zimbardo (2021)\nArtemyev et al. (2020)"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Updates",
    "section": "",
    "text": "Updates\n\n\n\n\nQuestions\n\nOrder of magnitude of estimation of the scattering rate.\nThe validality of small \\(κ\\) in observations and its implications in quasi-adibatic approximation.\nThe validality of approximate Hamiltonian form for off-center scattering.\n\n\n\nTODOs\n\nCheck the algorithm for energy conservation (Boris pusher)\nGPU acceleration\n\nDynamicalSystems.jl - Currently, the limits can not be changed with time.\n\nSaving as a DataFrame is more space-efficient than saving as a vector of dictionaries"
  },
  {
    "objectID": "presentations/index.html",
    "href": "presentations/index.html",
    "title": "Ion scattering by solar wind discontinuities",
    "section": "",
    "text": "Introduction\nThe transport of energetic particles within the heliosphere is significantly influenced by the turbulent magnetic field present in the solar wind. However, this turbulence should not be regarded merely as a collection of random magnetic field fluctuations. Instead, the nonlinear energy cascade process results in the formation of coherent structures. These coherent structures have been shown to act as efficient particle scatterers in non-collisional plasmas (Artemyev et al. 2020).\n\n\n\nMoraal (2013)\n\n\n\n\nTest particle simulations\n\\[\n\\mathbf{B} = B_0 (\\cos θ \\ e_z + \\sin θ ( \\sin φ(z) \\ e_z + \\cos φ (z) \\ e_y))\n\\]\nwith \\(φ(z) = β \\tanh(z)\\)\nDimensionless form of the motion equation:\n\\[\n\\frac{d (γ \\mathbf{v})}{dt} = \\mathbf{v} \\times \\mathbf{B} ,\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n\\]\n\n\\(\\mathbf{B} \\rightarrow \\mathbf{B} / B_0\\) : background magnetic field magnitude\n\\(\\mathbf{r} \\rightarrow \\mathbf{r} / L\\) : discontinuity \\(L\\)\n\\(t \\rightarrow t/Ω_0\\) : gyroperiod\n\\(v \\rightarrow v/v_0\\) : characteristic velocity \\(v_0 = Ω_0 L\\)\n\n\n\nParameters\n\n\\(Δ|B|/|B| &gt; 0.05\\) or \\(ω &gt; 60°\\)\nThe most probable values in the 3D distribution are a characteristic velocity (\\(v_0\\)) of approximately 250 km/s, a in-plane rotation angle (\\(ω_{in}\\)) about 90 degrees, and an azimuthal angle (\\(θ\\)) of around 85 degrees.\n\n\nExamples of Pitch angle scattering\n\n\n\nExample of pitch angle scattering.\n\n\n\n\n\nExample of multiple pitch angle scattering for different energies\n\n\n\nPitch angle scattering by typical discontinuity\n\nWith in-plane rotation angle (\\(ω_{in}\\)) about 90 degrees, and azimuthal angle (\\(θ\\)) of around 85 degrees.\n\n\nExamples of transition matrix\n\n\n\nTransition matrix\n\n\n\nTransition matrix for 100 keV particles.\n\n\n\n\n\nTransition matrix for different particle energies\n\n\n\n\n\nMixing rates\n\n\n\n\n\n\n\n\n\n\nReferences\n\nArtemyev, A. V., A. I. Neishtadt, A. A. Vasiliev, V. Angelopoulos, A. A. Vinogradov, and L. M. Zelenyi. 2020. “Superfast Ion Scattering by Solar Wind Discontinuities.” Physical Review E 102 (3): 033201. https://doi.org/10.1103/PhysRevE.102.033201.\n\n\nMoraal, H. 2013. “Cosmic-Ray Modulation Equations.” Space Science Reviews 176 (1): 299–319. https://doi.org/10.1007/s11214-011-9819-3."
  },
  {
    "objectID": "notebooks/03_surrogate.html",
    "href": "notebooks/03_surrogate.html",
    "title": "Compare the effect of coherent structures on test particle dynamics (surrogate testing)",
    "section": "",
    "text": "Compare the effect of coherent structures on test particle dynamics (surrogate testing)\nJuliaDynamics/TimeseriesSurrogates.jl: A Julia package for generating timeseries surrogates\nusing CurrentSheetTestParticle\nusing TestParticle\nusing StaticArrays\nusing TimeseriesSurrogates, CairoMakie\ninclude(\"../src/io.jl\")\ninclude(\"../src/plot.jl\")\ninclude(\"../src/utils.jl\")\nv = 8\nβ = 47.5 # CurrentSheetTestParticle.DEFAULT_β\nθ = 85 # CurrentSheetTestParticle.DEFAULT_θ\ninit_kwargs = (; Nw=90, Nϕ=120)\nsave_everystep = false\n# start = CurrentSheetTestParticle.init_z_pos(v) |&gt; abs\nz = range(-3, 3; length=4086)\nφ = β * tanh.(z)\nd = ProblemParams(; v, β, θ, init_kwargs)\nmethod = RandomFourier(true)\nmethod = RelativePartialRandomization()\nmethod = IAAFT()\ns = surrogate(φ, method)\nsurroplot(φ, s)\nBx = sind(θ) .* sind.(φ)\nBx_s = sind(θ) .* sind.(s)\nBy = sind(θ) .* cosd.(φ)\nBy_s = sind(θ) .* cosd.(s)\n# surroplot(By, By_s)\nB_s = let B = zeros(3, length(z))\n    B[1, :] .= Bx_s\n    B[2, :] .= By_s\n    B[3, :] .= cosd(θ)\n    E(x) = SVector(0.0, 0.0, 0.0)\n    param = prepare(z, E, B; species=User, i=3)\n    param[3].field_function\nend\nsols_s, (wϕs,) = solve_params(B_s, v; init_kwargs, save_everystep);\nresult_s = process_sols(sols_s, B_s, wϕs)\nsols, (wϕs, B) = solve_params(d; save_everystep);\nresult = process_sols(sols, B, wϕs)\n\nresult.tmax .= CurrentSheetTestParticle.DEFAULT_TSPAN[2]\nresult_s.tmax .= CurrentSheetTestParticle.DEFAULT_TSPAN[2]\nusing GLMakie\nusing AlgebraOfGraphics\nGLMakie.activate!()\nlet v = histogram(; bins=64), dfs = subset_leave(result_s), df0 = subset_leave(result)\n    fig = Figure()\n    \n    ps = fig[1, 1]\n    plts = data(dfs) * mapping(xyw...) * v\n    fg = draw!(ps, plts; axis=w_axis)\n    colorbar!(ps[1,2], fg)\n    Label(ps[0, 1], \"Surrogate\"; tellwidth=false)\n\n    p0 = fig[1, 2]\n    plt0 = data(df0) * mapping(xyw...) * v\n    draw!(p0, plt0; axis=w_axis)\n    colorbar!(p0[1,2], fg)\n    Label(p0[0, 1], \"Original\"; tellwidth=false)\n\n    Label(fig[0, 1:end], \"θ = $(d.θ)°, β = $(d.β)°\")\n\n    surroplot!(fig[2, 1], φ, s)\n    surroplot!(fig[2, 2], Bx, Bx_s)\n    surroplot!(fig[2, 3], By, By_s)\n\n    Label(fig[2, 1][0, 1], \"φ\"; tellwidth=false)\n    Label(fig[2, 2][0, 1], \"Bx\"; tellwidth=false)\n    Label(fig[2, 3][0, 1], \"By\"; tellwidth=false)\n\n    fig\nend",
    "crumbs": [
      "Compare the effect of coherent structures on test particle dynamics (surrogate testing)"
    ]
  },
  {
    "objectID": "notebooks/04_normalization.html",
    "href": "notebooks/04_normalization.html",
    "title": "",
    "section": "",
    "text": "How would normalization affect the transition matrix?",
    "crumbs": [
      "Distribution"
    ]
  },
  {
    "objectID": "notebooks/04_normalization.html#transition-matrix",
    "href": "notebooks/04_normalization.html#transition-matrix",
    "title": "",
    "section": "Transition matrix",
    "text": "Transition matrix\ninclude(\"../src/tm.jl\")\nweights = 1 ./ results.t1\ntm = transition_matrix_w(results)\ntm_w = transition_matrix_w(results; weights)\nlet i = 5, lowclip = 1e-5, colorscale = log10, colorrange = (lowclip, 10)\n    kw = (; colorscale, colorrange)\n    f = Figure()\n\n    tmi = tm^i\n    @show sum(tmi; dims=2)\n    @show sum(tmi; dims=1)\n\n    plot!(Axis(f[1, 1]), tm; kw...)\n    plot!(Axis(f[2, 1]), tmi; kw...)\n    plot!(Axis(f[1, 2]), tm_w; kw...)\n    plot!(Axis(f[2, 2]), tm_w^i; kw...)\n    easy_save(\"tm/tm_weighted\")\nend\nlet i = 5, df = results, binedge = range(0, 1, length=32)\n    kw = (;)\n    binedges = (binedge, binedge)\n    h = Hist2D((df.s2α0, df.s2α1); binedges)\n    tm = transition_matrix(h)\n    tmi = tm^i\n    f = Figure()\n    plot!(Axis(f[1, 1]), tm; kw...)\n    plot!(Axis(f[2, 1]), tmi; kw...)\n    @info sum(tmi; dims=1)\n    @info sum(tmi; dims=2)\n    f\nend\nψ_scale() = scales(Color=(; colormap=:brocO))\n\nlet df = results, xy = (w0, ϕ0), figure = (; size=(1200, 600))\n    f = Figure(; figure...)\n\n    spec = data(results) * mapping(xyw...) * density_layer()\n    cdraw!(f[1, 1], spec, tm_scale(); axis=w_axis)\n\n    gl = f[1, 2]\n    l = data(df) * mapping(xy...)\n    cdraw!(gl[1, 1], l * (; color=Δw))\n    cdraw!(gl[2, 1], l * (; color=Δt))\n    cdraw!(gl[3, 1], l * (; color=:ψ1,), ψ_scale(); colorbar=(; colormap=(:brocO)))\n    # cdraw!(gl[3, 1], l * (; color=(:Δw, :t1) =&gt; (x, y) -&gt; x / y))\n\n    easy_save(\"tm/Δw_Δt\")\nend\n\nAveraging\nusing StatsBase\nresults_avg = combine(groupby(results, :w0), :Δψ =&gt; mean, :Δw =&gt; mean; renamecols=false)\nsort!(results_avg, :w0)\nresults_avg.Δw_cumsum .= cumsum(results_avg.Δw)\n\nr = renamer([\"&lt;Δψ&gt;\", \"&lt;Δ cos α&gt;\", \"&lt;Δ cos α&gt; cumsum\"])\nys = [:Δψ, :Δw,]\ndraw(data(results_avg) * mapping(w0, ys; color=dims(1) =&gt; r) * visual(Scatter))",
    "crumbs": [
      "Distribution"
    ]
  },
  {
    "objectID": "notebooks/04_normalization.html#distribution",
    "href": "notebooks/04_normalization.html#distribution",
    "title": "",
    "section": "Distribution",
    "text": "Distribution\nusing DataFramesMeta\n\nfunction process_results_gryo!(df)\n    @chain df begin\n        @rtransform!(:ψ1 = inverse_v(:u1, :B)[3])\n        @transform!(:Δψ = rem2pi.(:ψ1 - :ϕ0, RoundDown))\n    end\nend\n\n@chain results begin\n    @transform!(\n        :s2α0 = sind.(:α0) .^ 2,\n        :s2α1 = sind.(:α1) .^ 2,\n        :leave = :t1 .!= tmax\n    )\n    process_results_gryo!\nend\nw_bins = range(-1, 1, length=129)\nα_bins = range(0, 180, length=129)\nsinα_bins = range(0, 1, length=63)\n\nf = Figure(; size=(1200, 600))\nl = data(results) * mapping(row=dims(1) =&gt; renamer([\"Initial\", \"Final\"]), col=:iter =&gt; nonnumeric)\nnormalization = :probability\ndraw!(f[1, 1], l * mapping([w0, w1] .=&gt; \"cos(α)\") * histogram(; bins=w_bins, normalization))\ndraw!(f[1, 2], l * mapping([α0, α1] .=&gt; \"α\") * histogram(; bins=α_bins, normalization))\ndraw!(f[1, 3], l * mapping([:s2α0, :s2α1] .=&gt; \"sin(α)^2\") * histogram(; bins=sinα_bins, normalization))\nf\nψ_bins = range(0, 2π, length=32)\n\ndraw(l * mapping([ϕ0, :ψ1] .=&gt; \"ψ\"; layout=leave) * histogram(; bins=ψ_bins))\n\ndraw(data(results) * mapping(:Δψ; layout=leave) * histogram())",
    "crumbs": [
      "Distribution"
    ]
  },
  {
    "objectID": "notebooks/04_normalization.html#cumulative-distribution",
    "href": "notebooks/04_normalization.html#cumulative-distribution",
    "title": "",
    "section": "Cumulative distribution",
    "text": "Cumulative distribution\nusing StatsBase, Distributions\n\"\"\"\n    EmpiricalDistribution(data::Vector{T} where T &lt;: Real)\n\nCreate a discrete empirical distribution based on observations.\n\"\"\"\nfunction EmpiricalDistribution(data)\n    data = sort(data) #sort the observations\n    empirical_cdf = ecdf(data) #create empirical cdf\n    data_clean = unique(data) #remove duplicates to avoid allunique error\n    cdf_data = empirical_cdf.(data_clean) #apply ecdf to data\n    pmf_data = vcat(cdf_data[1], diff(cdf_data)) #create pmf from the cdf\n    DiscreteNonParametric(data_clean, pmf_data) #define distribution\nend\n\nfunction rand_jump(x0; da=ecdfs_da)\n    d = da[x=Near(x0)]\n    rand(d)\nend\n\nfunction rand_jumps(x::AbstractVector, n; kw...)\n    for i in 1:n\n        push!(x, rand_jump(x[end]; kw...))\n    end\n    return x\nend\n\nrand_jumps(x0; n=1, kw...) = rand_jumps([x0], n; kw...)\nx = :w0\ny = :w1\n\nx = :s2α0\ny = :s2α1\n\nfunction df_rand_jumps(x, y; n = 100, counts=16)\n    ecdfs = combine(\n        groupby(results, x),\n        y =&gt; EmpiricalDistribution;\n        renamecols=false\n    )\n    sort!(ecdfs, x)\n\n    da = DimArray(ecdfs[!, y], (x=ecdfs[!, x],))\n\n    xs = repeat(ecdfs[!, x], counts)\n\n    xs_jumps = rand_jumps.(xs; n, da=da) |&gt; stack\nend\n\ns2α0_s2α1_jumps = df_rand_jumps(:s2α0, :s2α1; n=100)\nw0_w1_jumps = df_rand_jumps(:w0, :w1; n=100)\n\nusing CairoMakie\n\nlet position = :rb,\n\n    mid_index = div(size(s2α0_s2α1_jumps, 1), 2)\n\n    f = Figure(;)\n    ax = Axis(f[1, 1]; xlabel = \"sin(α)^2\", ylabel = \"F\")\n    ecdfplot!(s2α0_s2α1_jumps[1, :]; label=\"Initial\")\n    ecdfplot!(s2α0_s2α1_jumps[mid_index, :]; label=\"Intermediate\", color=Cycled(2))\n    ecdfplot!(s2α0_s2α1_jumps[end, :]; label=\"Final\", color=Cycled(3))\n    \n    Axis(f[1, 2]; xlabel = \"cos(α)\")\n    ecdfplot!(w0_w1_jumps[1, :]; label=\"Initial\")\n    ecdfplot!(w0_w1_jumps[mid_index, :]; label=\"Intermediate\", color=Cycled(2))\n    ecdfplot!(w0_w1_jumps[end, :]; label=\"Final\", color=Cycled(3))\n\n    Legend(f[0, 1:end], ax; tellheight = true, orientation = :horizontal)\n    easy_save(\"pa_cdf\")\nend",
    "crumbs": [
      "Distribution"
    ]
  },
  {
    "objectID": "notebooks/10_test_tm.html",
    "href": "notebooks/10_test_tm.html",
    "title": "Empirically verify the perturbation sensitivity of doubly stochastic matrices",
    "section": "",
    "text": "2. Numerical Stability Considerations\n\nNumerical stability refers to how errors—stemming from finite precision arithmetic, rounding, and truncation—propagate through computations involving the matrix.\n\na. Conditioning\n\n    •   Condition Number: The condition number of a matrix measures how much the output value can change for a small change in the input. For doubly stochastic matrices, the condition number can vary widely depending on the specific matrix. Some are well-conditioned (small condition numbers), implying that they are relatively stable under numerical perturbations, while others are ill-conditioned (large condition numbers), making them sensitive to errors.\n    •   Perturbation Sensitivity: Doubly stochastic matrices can be sensitive to perturbations, especially those near the boundary of the Birkhoff polytope (i.e., those close to permutation matrices). Small numerical errors might push such matrices outside the set of doubly stochastic matrices or significantly alter their properties.\n\n4. Theoretical Insights and Research\n\nResearch into the numerical stability of doubly stochastic matrices highlights several key points:\n\n    •   Birkhoff Polytope Structure: The geometric properties of the Birkhoff polytope influence stability. Matrices that lie deep within the polytope (far from permutation matrices) tend to be better conditioned than those near the vertices.\n    •   Spectral Properties: The eigenvalues and singular values of doubly stochastic matrices play a role in their numerical behavior. For instance, the presence of eigenvalues close to zero can indicate potential instability.\n    •   Random Doubly Stochastic Matrices: Probabilistic analyses suggest that randomly generated doubly stochastic matrices often exhibit better conditioning on average, though specific instances may still be problematic.",
    "crumbs": [
      "Empirically verify the perturbation sensitivity of doubly stochastic matrices"
    ]
  },
  {
    "objectID": "notebooks/10_test_tm.html#generating-a-doubly-stochastic-matrix",
    "href": "notebooks/10_test_tm.html#generating-a-doubly-stochastic-matrix",
    "title": "Empirically verify the perturbation sensitivity of doubly stochastic matrices",
    "section": "2. Generating a Doubly Stochastic Matrix",
    "text": "2. Generating a Doubly Stochastic Matrix\n\nThere are multiple ways to generate a doubly stochastic matrix. One common method is using the Sinkhorn-Knopp algorithm, which iteratively normalizes the rows and columns of a non-negative matrix to make it doubly stochastic.\n\n\nfunction sinkhorn_knopp(A; max_iters=1000, tol=1e-9, normalize_rows=true, normalize_cols=true)\n    \"\"\"\n    Applies the Sinkhorn-Knopp algorithm to matrix A to make it doubly stochastic.\n\n    # Arguments\n    - `A::Matrix{Float64}`: Non-negative input matrix\n    - `max_iters::Int`: Maximum number of iterations\n    - `tol::Float64`: Tolerance for convergence\n    - `normalize_rows::Bool`: Whether to normalize rows\n    - `normalize_cols::Bool`: Whether to normalize columns\n\n    # Returns\n    - `Matrix{Float64}`: Doubly stochastic matrix\n    \"\"\"\n    A = copy(A)\n    n, m = size(A)\n    if n != m\n        error(\"Matrix must be square.\")\n    end\n    for iter in 1:max_iters\n        if normalize_rows\n            row_sums = sum(A, dims=2)\n            A = A ./ row_sums\n        end\n        if normalize_cols\n            col_sums = sum(A, dims=1)\n            A = A ./ col_sums\n        end\n        # Check convergence\n        row_diff = normalize_rows ? maximum(abs.(sum(A, dims=2) .- 1)) : 0.0\n        col_diff = normalize_cols ? maximum(abs.(sum(A, dims=1) .- 1)) : 0.0\n        if row_diff &lt; tol && col_diff &lt; tol\n            println(\"Converged in $iter iterations.\")\n            break\n        end\n        if iter == max_iters\n            println(\"Reached maximum iterations without full convergence.\")\n        end\n    end\n    return A\nend\n\n# Example: Generate a random non-negative matrix and make it doubly stochastic\nRandom.seed!(123)  # For reproducibility\nn = 5  # Size of the matrix\nA = rand(n, n)\nA_ds = sinkhorn_knopp(A)\nprintln(\"Doubly Stochastic Matrix A_ds:\\n\")\ndisplay(A_ds)\nprintln(\"Row sums: \", sum(A_ds, dims=2))\nprintln(\"Column sums: \", sum(A_ds, dims=1))\n\ni = 5\nA_ds_i = A_ds^i\nprintln(\"Matrix A_ds^$i:\\n\")\ndisplay(A_ds_i)\nprintln(\"Row sums: \", sum(A_ds_i, dims=2))\nprintln(\"Column sums: \", sum(A_ds_i, dims=1))",
    "crumbs": [
      "Empirically verify the perturbation sensitivity of doubly stochastic matrices"
    ]
  },
  {
    "objectID": "notebooks/10_test_tm.html#introducing-perturbations",
    "href": "notebooks/10_test_tm.html#introducing-perturbations",
    "title": "Empirically verify the perturbation sensitivity of doubly stochastic matrices",
    "section": "3. Introducing Perturbations",
    "text": "3. Introducing Perturbations\nTo assess perturbation sensitivity, we can introduce small random perturbations to the doubly stochastic matrix and observe how its properties change.\nfunction perturb_matrix(A::Matrix{Float64}, noise_level::Float64)\n    \"\"\"\n    Adds Gaussian noise to matrix A and projects it back to doubly stochastic.\n    \n    # Arguments\n    - `A::Matrix{Float64}`: Original doubly stochastic matrix\n    - `noise_level::Float64`: Standard deviation of Gaussian noise\n    \n    # Returns\n    - `Matrix{Float64}`: Perturbed doubly stochastic matrix\n    \"\"\"\n    n, m = size(A)\n    noise = randn(n, m) * noise_level\n    A_perturbed = A + noise\n    # Ensure non-negativity\n    A_perturbed[A_perturbed .&lt; 0] .= 0.0\n    # Re-apply Sinkhorn-Knopp to make it doubly stochastic\n    A_perturbed_ds = sinkhorn_knopp(A_perturbed)\n    return A_perturbed_ds\nend\n\nfunction perturb_right_stochastic(A::Matrix{Float64}, noise_level::Float64)\n    \"\"\"\n    Perturbs a right stochastic matrix while preserving row sums.\n\n    # Arguments\n    - `A::Matrix{Float64}`: Original right stochastic matrix\n    - `noise_level::Float64`: Standard deviation of Gaussian noise\n\n    # Returns\n    - `Matrix{Float64}`: Perturbed right stochastic matrix\n    \"\"\"\n    n, m = size(A)\n    # Add Gaussian noise\n    noise = randn(n, m) * noise_level\n    A_perturbed = A + noise\n    # Set negative entries to a small positive value to maintain non-negativity\n    A_perturbed[A_perturbed .&lt; 1e-8] .= 1e-8\n    # Renormalize rows to sum to 1\n    row_sums = sum(A_perturbed, dims=2)\n    A_perturbed_rs = A_perturbed ./ row_sums\n    return A_perturbed_rs\nend\n\n\n# Example usage\nnoise_level = 0.05\nA_rs_perturbed = perturb_right_stochastic(A_ds, noise_level)\nprintln(\"Perturbed Right Stochastic Matrix A_rs_perturbed:\\n\", A_rs_perturbed)\nprintln(\"Row sums: \", sum(A_rs_perturbed, dims=2))\nprintln(\"Column sums: \", sum(A_rs_perturbed, dims=1))\n\nA_rs_perturbed_i = A_rs_perturbed^100\nprintln(\"Matrix A_rs_perturbed^$i:\\n\")\ndisplay(A_rs_perturbed_i)\nprintln(\"Row sums: \", sum(A_rs_perturbed_i, dims=2))\nprintln(\"Column sums: \", sum(A_rs_perturbed_i, dims=1)) \n\nfunction compute_metrics(A_original::Matrix{Float64}, A_perturbed::Matrix{Float64})\n    \"\"\"\n    Computes various metrics to assess the difference between two matrices.\n    \n    # Arguments\n    - `A_original::Matrix{Float64}`: Original doubly stochastic matrix\n    - `A_perturbed::Matrix{Float64}`: Perturbed doubly stochastic matrix\n    \n    # Returns\n    - `Dict`: Dictionary containing computed metrics\n    \"\"\"\n    difference = A_original - A_perturbed\n    absolute_diff = maximum(abs.(difference))\n    relative_diff = maximum(abs.(difference) ./ A_original)\n    \n    # Condition numbers\n    cond_original = cond(A_original)\n    cond_perturbed = cond(A_perturbed)\n    \n    # Eigenvalues\n    eigen_original = eigen(A_original).values\n    eigen_perturbed = eigen(A_perturbed).values\n    eigen_diff = maximum(abs.(eigen_original - eigen_perturbed))\n    \n    # Singular values\n    singular_original = svdvals(A_original)\n    singular_perturbed = svdvals(A_perturbed)\n    singular_diff = maximum(abs.(singular_original - singular_perturbed))\n    \n    # Frobenius norm\n    # frob_norm = norm(difference, Frobenius)\n    \n    return Dict(\n        :absolute_difference =&gt; absolute_diff,\n        :relative_difference =&gt; relative_diff,\n        :condition_number_original =&gt; cond_original,\n        :condition_number_perturbed =&gt; cond_perturbed,\n        :max_eigenvalue_difference =&gt; eigen_diff,\n        :max_singular_difference =&gt; singular_diff\n        # :frobenius_norm =&gt; frob_norm\n    )\nend\n\n# Compute metrics\nmetrics = compute_metrics(A_ds, A_perturbed)\nprintln(\"Perturbation Metrics:\")\nfor (key, value) in metrics\n    println(\"$key: $value\")\nend\nusing CairoMakie\n# Define a range of noise levels\nnoise_levels = [0.001, 0.005, 0.01, 0.05, 0.1]\n\n# Initialize containers for metrics\nabsolute_diffs = Float64[]\nrelative_diffs = Float64[]\ncond_originals = Float64[]\ncond_perturbed_vals = Float64[]\nmax_eigen_diffs = Float64[]\nmax_singular_diffs = Float64[]\nfrob_norms = Float64[]\n\nfor noise in noise_levels\n    A_p = perturb_matrix(A_ds, noise)\n    m = compute_metrics(A_ds, A_p)\n    push!(absolute_diffs, m[:absolute_difference])\n    push!(relative_diffs, m[:relative_difference])\n    push!(cond_originals, m[:condition_number_original])\n    push!(cond_perturbed_vals, m[:condition_number_perturbed])\n    push!(max_eigen_diffs, m[:max_eigenvalue_difference])\n    push!(max_singular_diffs, m[:max_singular_difference])\n    # push!(frob_norms, m[:frobenius_norm])\nend\n\n# Plotting the results\nf = Figure()\nax = Axis(f[1, 1], xlabel=\"Noise Level\", ylabel=\"Metric Value\", title=\"Sensitivity Analysis\")\n\nplot!(noise_levels, absolute_diffs, label=\"Absolute Difference\", marker=:o)\nplot!(noise_levels, relative_diffs, label=\"Relative Difference\", marker=:o)\naxislegend(ax, position=:lt)\n# plot!(noise_levels, frob_norms, label=\"Frobenius Norm\", marker=:o)\ndisplay(f)",
    "crumbs": [
      "Empirically verify the perturbation sensitivity of doubly stochastic matrices"
    ]
  }
]