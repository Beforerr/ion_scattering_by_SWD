{
  "hash": "64b153fa79bb06f0e9a52984a4ac42ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nexecute: \n  eval: false\n---\n\n\n\n\n# Mixing rates\n\n\n\n\n```{julia}\nbegin\n    using DrWatson\n    using FHist\n    using HDF5\n    using StatsBase: sample\n    using DataFrames\n    using DimensionalData\n    using DimensionalData: dims\n    using StatsBase: mean\n    using Beforerr\n    import CairoMakie.Makie.SpecApi as S\n    include(\"../src/io.jl\")\n    include(\"../src/plot.jl\")\n    include(\"../src/jump.jl\")\n    VMIN = 0.25\n    VMAX = 256\nend\n```\n\n```{julia}\ndir = \"simulations\"\ndfs = get_result_dfs(; dir)\n```\n\n```{julia}\nforeach(get_result, eachrow(dfs))\n@rtransform!(dfs, :ecdf_da = ecdf_da(:results, \"s2α0\", \"Δs2α\"))\n```\n\n```{julia}\nfunction load_obs_hist(; file=datadir(\"obs/\") * \"wind_hist3d.h5\")\n    h = h5readhist(file, \"hist\")\n    bc = bincenters(h)\n    vs = 2 .^ bc[1]\n    βs = bc[2] ./ 2\n    θs = bc[3]\n    return DimArray(bincounts(h), (v=vs, β=βs, θ=θs))\nend\n\nfunction dargmax(p)\n    # Note: iteration is deliberately unsupported for CartesianIndex.\n    name.(dims(p)), map(getindex, dims(p), Tuple(argmax(p)))\nend\n\nfunction check_obs_hist(p)\n    # check the maxximum value of the observation data\n    @info maximum(p)\n    @info dargmax(p)\nend\n\np = load_obs_hist()\n\nfunction sample_hist(p, args...)\n    a = []\n    wv = Float64[]\n    foreach(Iterators.product(dims(p)...)) do t\n        push!(a, t)\n        push!(wv, p[v=At(t[1]), β=At(t[2]), θ=At(t[3])])\n    end\n    sample(a, Weights(wv), args...)\nend\n\n```\n\n```{julia}\nfunction subset_ecdf(v0, β, θ, vP; df=dfs, vmin=VMIN, vmax=VMAX)\n    v = clamp(vP / v0, vmin, vmax)\n    sdf = @subset(df, :v .== v, :β .== β, :θ .== θ; view=true)\n    ecdf_das = sdf[!, :ecdf_da]\n    if isempty(ecdf_das)\n        @warn \"No data found for v=$v, β=$β, θ=$θ, v0=$v0\"\n    elseif length(ecdf_das) != 1\n        @warn \"Multiple data found for v=$v, β=$β, θ=$θ, v0=$v0\"\n    end\n    return ecdf_das[1]\nend\n\nfunction rand_jumps(x0, vP, p; n=10, kw...)\n    x = [x0]\n    samples = sample_hist(p, n)\n\n    for i in 1:n\n        ecdf_da = subset_ecdf(samples[i]..., vP)\n        x_new = x[end] + rand_jump(x[end], ecdf_da)\n        push!(x, x_new)\n    end\n    return x\nend\n\nrand_jumps(x0, vP; p=p, kw...) = rand_jumps(x0, vP, p; kw...)\n```\n\n```{julia}\nvPs = 4 .^ (3:6)\ncounts = 1024\nvPs_jumps = map(vPs) do vP\n    xs = range(0, 1, length=counts)\n    jumps = rand_jumps.(xs, vP; n=100, p=p)\n    (; vP, jumps)\nend\n\nvPs_jumps_ani = map(vPs) do vP\n    xs = range(0.4, 0.6, length=counts)\n    jumps = rand_jumps.(xs, vP; n=100, p=p)\n    (; vP, jumps)\nend\n```\n\n```{julia}\nfunction m2(jumps)\n    jumps_s = stack(jumps)\n    diffs = jumps_s .- jumps_s[1, :]'\n    m1 = mean(diffs, dims=2)\n    m2 = mean(diffs .^ 2, dims=2) - m1 .^ 2\n    vec(m2)\nend\n\nfunction jumps_ecdfplot(jumps; idxs=[1, div(size(jumps, 1), 2), size(jumps, 1)], kw...)\n    linestyles = [:solid, :dash, :dot]\n    ps = map(enumerate(idxs)) do (i, idx)\n        S.ECDFPlot(jumps[idx, :]; linestyle=linestyles[i], kw...)\n    end\n    S.Axis(; plots=ps, xlabel=\"sin(α)^2\", ylabel=\"F\")\nend\n\n\nfunction jumps_ecdfplot_grid(jumps_vs; kw...)\n    ax1 = jumps_ecdfplot(stack(jumps_vs[1].jumps); color=Cycled(1), kw...)\n    ax2 = jumps_ecdfplot(stack(jumps_vs[2].jumps); color=Cycled(2), kw...)\n    ax3 = jumps_ecdfplot(stack(jumps_vs[3].jumps); color=Cycled(3), kw...)\n    ax4 = jumps_ecdfplot(stack(jumps_vs[4].jumps); color=Cycled(4), kw...)\n\n    S.GridLayout([ax1 ax2; ax3 ax4])\nend\n\n```\n\n```{julia}\nf = Figure(;)\nax = Axis(f[1, 1]; xlabel=\"n\", ylabel=\"M2\")\n\ncontents = map(vPs_jumps) do t\n    vP, jumps = t\n    m2s = m2(jumps)\n    scatterlines!(m2s; label=\"vP=$vP\")\nend\n\nlabels = ergs_approx[1:4]\n\nax = Axis(f[2, 1]; xlabel=\"n\", ylabel=\"M2\")\ncontents = map(vPs_jumps_ani) do t\n    vP, jumps = t\n    m2s = m2(jumps)\n    scatterlines!(m2s; label=\"vP=$vP\")\nend\n\nidxs = [1, 2, 4]\n\ngl1 = jumps_ecdfplot_grid(vPs_jumps; idxs)\ngl2 = jumps_ecdfplot_grid(vPs_jumps_ani; idxs)\ngl = S.GridLayout([gl1, gl2])\nplot(f[1:end, 2], gl)\n\nLegend(f[1:end, 3], contents, labels, \"Energy\")\n\neasy_save(\"mixing_rate_sin2\")\n\n# let jumps = s2α_jumps, n = 8\n#     sample_jumps = sample(jumps, n)\n#     scatterlines!(vec(m2))\n\n#     ax = Axis(f[2, 1]; xlabel = \"n\", ylabel = \"sin(α)^2\")\n#     stairs!.(sample_jumps)\n#     f\n# end\n```\n\n```{julia}\nlabels = ergs_approx[1:4]\ncontents = map(vPs_jumps_ani) do t\n    vP, jumps = t\n    m2s = m2(jumps)\n    S.ScatterLines(m2s; label=\"vP=$vP\")\nend\n\ngl1 = S.GridLayout([S.Axis(; plots=contents, xlabel=\"n\", ylabel=\"M2\")])\ngl2 = jumps_ecdfplot_grid(vPs_jumps_ani; idxs)\nplot(S.GridLayout([gl1, gl2], rowsizes = [Auto(2), Auto(3)]))\neasy_save(\"mr/mixing_rate_sin2_ani\")\n```\n\n",
    "supporting": [
      "02_mixing_rates_files"
    ],
    "filters": [],
    "includes": {}
  }
}